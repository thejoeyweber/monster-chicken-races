<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple SVG Editor</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            font-family: Arial, sans-serif;
            color: white;
            background: #2a2a2a;
        }
        #editor-container {
            display: flex;
            flex-direction: column;
            height: 100%;
        }
        #toolbar {
            background: #3a3a3a;
            padding: 10px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        #editor-layout {
            display: flex;
            flex: 1;
            overflow: hidden;
        }
        #canvas-container {
            flex: 1;
            background: #1a1a1a;
            overflow: auto;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }
        
        .canvas-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            box-sizing: border-box;
        }
        
        #grid-canvas {
            z-index: 1;
            pointer-events: none; /* Grid never receives mouse events */
        }
        
        #edit-canvas {
            z-index: 2; /* Content in the middle layer */
            background: #f5f5f5; /* Light gray background for the edit area */
        }
        
        #ui-canvas {
            z-index: 3; /* UI elements on top */
            pointer-events: none; /* Only specific UI elements receive events */
            background: transparent; /* Transparent so we can see through to the lower layers */
        }
        
        /* UI elements that need interaction should override pointer-events */
        #ui-canvas .drag-handle {
            pointer-events: all;
        }
        
        #svg-canvas {
            background: #f5f5f5;
            margin: auto;
        }
        .tool-button {
            padding: 8px 12px;
            background: #4a4a4a;
            border: none;
            border-radius: 4px;
            color: white;
            cursor: pointer;
        }
        .tool-button:hover {
            background: #5a5a5a;
        }
        .tool-button.active {
            background: #e63946;
        }
        #path-editor {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: #3a3a3a;
            padding: 10px;
            display: none;
        }
        #path-data {
            width: 100%;
            height: 80px;
            background: #1a1a1a;
            color: white;
            border: 1px solid #4a4a4a;
            font-family: monospace;
            resize: vertical;
        }
        .color-picker {
            display: flex;
            gap: 5px;
        }
        .color-swatch {
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            border: 2px solid transparent;
        }
        .color-swatch.active {
            border-color: white;
        }
        .property-group {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .property-label {
            width: 60px;
        }
        .property-input {
            background: #1a1a1a;
            color: white;
            border: 1px solid #4a4a4a;
            padding: 5px;
        }
        .transform-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            background: #2a2a2a;
            padding: 10px;
            border-top: 1px solid #4a4a4a;
        }
        .transform-title {
            font-weight: bold;
            margin-right: 10px;
        }
        #code-panel {
            width: 300px;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            border-left: 1px solid #4a4a4a;
        }
        #object-tree-panel {
            width: 250px;
            background: #1a1a1a;
            display: flex;
            flex-direction: column;
            border-right: 1px solid #4a4a4a;
            overflow: auto;
            padding: 0;
            font-family: monospace;
        }
        #object-tree {
            flex: 1;
            padding: 8px;
            overflow: auto;
            user-select: none;
        }
        .tree-item {
            margin: 2px 0;
            cursor: pointer;
            padding: 4px;
            display: flex;
            align-items: flex-start;
            color: #ddd;
            position: relative;
            transition: background 0.2s;
        }
        .tree-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .tree-item.selected {
            background: rgba(230, 57, 70, 0.2);
            border-left: 2px solid #e63946;
        }
        .tree-item-icon {
            width: 16px;
            height: 16px;
            margin-right: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            color: #888;
        }
        .tree-item-content {
            flex: 1;
            min-width: 0;
            padding-left: 4px;
        }
        .tree-item-name {
            color: #eee;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .tree-item-attrs {
            color: #888;
            font-size: 11px;
        }
        .child-items {
            margin-left: 20px;
            position: relative;
        }
        .child-items::before {
            content: '';
            position: absolute;
            left: -12px;
            top: 0;
            bottom: 0;
            width: 1px;
            background: #444;
        }
        .expand-icon {
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 8px;
            color: #888;
            cursor: pointer;
            flex-shrink: 0;
        }
        .points-toggle {
            padding: 2px 6px;
            font-size: 11px;
            color: #888;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            margin-left: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .points-toggle:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        .points-container {
            margin: 4px 0 4px 24px;
            padding-left: 8px;
            border-left: 1px dashed #666;
        }
        .point-item {
            padding: 3px 6px;
            font-size: 11px;
            color: #bbb;
            cursor: pointer;
            border-radius: 2px;
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .point-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .point-item.selected {
            background: rgba(255, 220, 40, 0.15);
            color: #fff;
        }
        .point-type {
            color: #666;
            font-size: 10px;
            padding: 1px 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }
        #canvas-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #zoom-value {
            min-width: 50px;
            text-align: center;
        }
        
        /* New style for path elements */
        .item-path {
            background: rgba(80, 40, 40, 0.4);
            border-left: 3px solid #e63946;
        }
        .item-g {
            background: rgba(40, 40, 80, 0.4);
            border-left: 3px solid #3a86ff;
        }
        .item-rect {
            background: rgba(40, 80, 40, 0.4);
            border-left: 3px solid #2a9d8f;
        }
        .item-circle {
            background: rgba(80, 80, 40, 0.4);
            border-left: 3px solid #fcbf49;
        }
        .selection-outline {
            fill: none;
            stroke: #e63946;
            stroke-width: 1;
            stroke-dasharray: 3, 3;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
        .drag-handle {
            fill: white;
            stroke: #333;
            stroke-width: 1;
            cursor: move;
            vector-effect: non-scaling-stroke;
        }
        .point-indicator {
            fill: rgba(255, 0, 0, 0.5);
            stroke: red;
            stroke-width: 0.5;
            r: 1.5;
            pointer-events: none;
            vector-effect: non-scaling-stroke;
        }
    </style>
</head>
<body>
    <div id="editor-container">
        <div id="toolbar">
            <button id="tool-select" class="tool-button active">Select</button>
            <button id="tool-path" class="tool-button">Path</button>
            <button id="tool-line" class="tool-button">Line</button>
            <button id="tool-rect" class="tool-button">Rect</button>
            <button id="tool-circle" class="tool-button">Circle</button>
            <button id="tool-text" class="tool-button">Text</button>
            
            <div class="property-group">
                <span class="property-label">Fill:</span>
                <div class="color-picker" id="fill-color">
                    <div class="color-swatch active" style="background: #ffffff;" data-color="#ffffff"></div>
                    <div class="color-swatch" style="background: #e63946;" data-color="#e63946"></div>
                    <div class="color-swatch" style="background: #f77f00;" data-color="#f77f00"></div>
                    <div class="color-swatch" style="background: #fcbf49;" data-color="#fcbf49"></div>
                    <div class="color-swatch" style="background: #2a9d8f;" data-color="#2a9d8f"></div>
                    <div class="color-swatch" style="background: #48cae4;" data-color="#48cae4"></div>
                    <div class="color-swatch" style="background: #3a86ff;" data-color="#3a86ff"></div>
                    <div class="color-swatch" style="background: #8338ec;" data-color="#8338ec"></div>
                    <div class="color-swatch" style="background: #000000;" data-color="#000000"></div>
                    <div class="color-swatch" style="background: none; border: 1px dashed #aaa;" data-color="none"></div>
                </div>
            </div>
            
            <div class="property-group">
                <span class="property-label">Stroke:</span>
                <div class="color-picker" id="stroke-color">
                    <div class="color-swatch" style="background: #ffffff;" data-color="#ffffff"></div>
                    <div class="color-swatch" style="background: #e63946;" data-color="#e63946"></div>
                    <div class="color-swatch" style="background: #f77f00;" data-color="#f77f00"></div>
                    <div class="color-swatch" style="background: #fcbf49;" data-color="#fcbf49"></div>
                    <div class="color-swatch" style="background: #2a9d8f;" data-color="#2a9d8f"></div>
                    <div class="color-swatch" style="background: #48cae4;" data-color="#48cae4"></div>
                    <div class="color-swatch" style="background: #3a86ff;" data-color="#3a86ff"></div>
                    <div class="color-swatch" style="background: #8338ec;" data-color="#8338ec"></div>
                    <div class="color-swatch active" style="background: #000000;" data-color="#000000"></div>
                    <div class="color-swatch" style="background: none; border: 1px dashed #aaa;" data-color="none"></div>
                </div>
            </div>
            
            <div class="property-group">
                <span class="property-label">Width:</span>
                <input type="number" id="stroke-width" class="property-input" value="1" min="0" max="10" step="0.5">
            </div>
            
            <button id="delete-selected" class="tool-button">Delete</button>
            <button id="duplicate-selected" class="tool-button">Duplicate</button>
            <button id="bring-to-front" class="tool-button">Bring to Front</button>
            <button id="send-to-back" class="tool-button">Send to Back</button>
            <button id="edit-path" class="tool-button">Edit Path</button>
        </div>
        
        <div class="transform-controls" id="transform-controls">
            <span class="transform-title">Transform:</span>
            <div class="property-group">
                <span class="property-label">Rotate (Â°):</span>
                <input type="number" id="rotate-value" class="property-input" value="0">
            </div>
            <div class="property-group">
                <span class="property-label">Scale X:</span>
                <input type="number" id="scale-x-value" class="property-input" value="1" step="0.1">
            </div>
            <div class="property-group">
                <span class="property-label">Scale Y:</span>
                <input type="number" id="scale-y-value" class="property-input" value="1" step="0.1">
            </div>
            <button id="apply-transform" class="tool-button">Apply</button>
            <button id="reset-transform" class="tool-button">Reset</button>
        </div>
        
        <div id="editor-layout">
            <div id="object-tree-panel">
                <div class="tree-header">Object Tree</div>
                <div id="object-tree"></div>
                <div style="display: flex; margin-top: 10px; gap: 5px;">
                    <button id="tree-delete" class="tool-button">Delete</button>
                    <button id="tree-duplicate" class="tool-button">Duplicate</button>
                </div>
            </div>
            
            <div id="canvas-container">
                <!-- Grid layer - background, fixed grid -->
                <svg id="grid-canvas" class="canvas-layer" width="100%" height="100%" viewBox="-50 -50 100 100">
                    <g id="grid"></g>
                </svg>
                
                <!-- Edit layer - content being edited -->
                <svg id="edit-canvas" class="canvas-layer" width="100%" height="100%" viewBox="-50 -50 100 100">
                    <g id="content"></g>
                </svg>
                
                <!-- UI layer - handles, indicators, and other UI elements -->
                <svg id="ui-canvas" class="canvas-layer" width="100%" height="100%" viewBox="-50 -50 100 100">
                    <g id="point-handles"></g>
                </svg>
                
                <div id="canvas-controls">
                    <button id="zoom-in" class="tool-button">+</button>
                    <span id="zoom-value">100%</span>
                    <button id="zoom-out" class="tool-button">-</button>
                </div>
            </div>
            
            <div id="code-panel">
                <div class="code-header">
                    SVG Code
                    <div>
                        <button id="undo-button" class="tool-button">Undo</button>
                        <button id="apply-code" class="tool-button">Apply</button>
                    </div>
                </div>
                <textarea id="code-view" spellcheck="false"></textarea>
            </div>
        </div>
        
        <div id="path-editor">
            <textarea id="path-data" spellcheck="false"></textarea>
            <div style="margin-top: 10px; display: flex; gap: 10px; justify-content: flex-end;">
                <button id="cancel-path-edit" class="tool-button">Cancel</button>
                <button id="apply-path-edit" class="tool-button">Apply</button>
            </div>
        </div>
    </div>
    
    <script>
        // Simple SVG Editor
        class SimpleSVGEditor {
            constructor() {
                console.log("Initializing SimpleSVGEditor");
                
                // Namespace for SVG elements
                this.ns = "http://www.w3.org/2000/svg";
                
                // Initialize variables
                this.selectedElement = null;
                this.selectedPoint = null;
                this.dragState = null;
                this.zoom = 100;
                this.defaultViewBox = "-50 -50 100 100"; // Store default viewBox
                this.history = [];
                this.historyIndex = -1;
                this.isDrawing = false;
                this.fillColor = '#ffffff';
                this.strokeColor = '#000000';
                this.strokeWidth = 1;
                this.currentTool = 'select';
                this.selectionOutline = null;
                this.dragHandles = [];
                
                // Bind methods to this instance
                this.handleMouseDown = this.handleMouseDown.bind(this);
                this.handleMouseMove = this.handleMouseMove.bind(this);
                this.handleMouseUp = this.handleMouseUp.bind(this);
                this.handleDragMove = this.handleDragMove.bind(this);
                this.handleDragEnd = this.handleDragEnd.bind(this);
                
                try {
                    // Find all canvas layers
                    this.gridCanvas = document.getElementById('grid-canvas');
                    this.editCanvas = document.getElementById('edit-canvas');
                    this.uiCanvas = document.getElementById('ui-canvas');
                    
                    // Check that all canvases exist
                    if (!this.gridCanvas || !this.editCanvas || !this.uiCanvas) {
                        console.error("One or more canvas layers not found");
                        return;
                    }
                    
                    // Set background color on the edit canvas
                    this.editCanvas.style.background = "#f5f5f5";
                    
                    // Get or create content group
                    this.content = this.editCanvas.querySelector('#content');
                    if (!this.content) {
                        console.log("Creating content group");
                        this.content = document.createElementNS(this.ns, 'g');
                        this.content.id = 'content';
                        this.editCanvas.appendChild(this.content);
                    }
                    
                    // Get or create point handles group
                    this.pointHandles = this.uiCanvas.querySelector('#point-handles');
                    if (!this.pointHandles) {
                        console.log("Creating point handles group");
                        this.pointHandles = document.createElementNS(this.ns, 'g');
                        this.pointHandles.id = 'point-handles';
                        this.uiCanvas.appendChild(this.pointHandles);
                    }
                    
                    this.codeView = document.getElementById('code-view');
                    this.treeContainer = document.getElementById('object-tree');
                    
                    console.log("Setting up UI components");
                    
                    // Setup the grid
                    this.setupGrid();
                    
                    // Setup event listeners with error handling
                    try { 
                        this.setupEventListeners(); 
                    } catch (e) { 
                        console.error("Error setting up event listeners:", e); 
                    }
                    
                    // Setup code editor with error handling
                    if (this.codeView) {
                        try { 
                            this.setupCodeEditor(); 
                        } catch (e) { 
                            console.error("Error setting up code editor:", e); 
                        }
                    }
                    
                    // Setup object tree with error handling
                    if (this.treeContainer) {
                        try { 
                            this.updateObjectTree(); 
                        } catch (e) { 
                            console.error("Error updating object tree:", e); 
                        }
                    }
                    
                    // Initial code view update
                    this.updateCodeView();
                    
                    console.log("Editor initialized successfully");
                } catch (e) {
                    console.error("Error during initialization:", e);
                }
            }
            
            // Setup the grid for visual reference
            setupGrid(x = -50, y = -50, width = 100, height = 100) {
                console.log(`Setting up grid: x=${x}, y=${y}, width=${width}, height=${height}`);
                
                // Find the grid container
                let grid = this.gridCanvas.querySelector('#grid');
                if (!grid) {
                    console.log("Grid container not found, creating...");
                    grid = document.createElementNS(this.ns, 'g');
                    grid.id = 'grid';
                    grid.setAttribute('class', 'grid');
                    grid.setAttribute('pointer-events', 'none'); // Make grid non-interactive
                    this.gridCanvas.appendChild(grid);
                } else {
                    // Clear existing grid
                    while (grid.firstChild) {
                        grid.removeChild(grid.firstChild);
                    }
                }
                
                // Calculate grid step based on size - larger steps for bigger viewBox
                const maxDimension = Math.max(width, height);
                const baseStep = 5;
                const gridStep = Math.max(baseStep, Math.ceil(maxDimension / 30));
                
                console.log(`Using grid step: ${gridStep} for maxDimension: ${maxDimension}`);
                
                // Ensure we draw a reasonable number of grid lines
                const maxLines = 100; // Safety limit
                
                // Round bounds to nice multiples of gridStep
                const xStart = Math.floor(x / gridStep) * gridStep;
                const yStart = Math.floor(y / gridStep) * gridStep;
                const xEnd = Math.ceil((x + width) / gridStep) * gridStep;
                const yEnd = Math.ceil((y + height) / gridStep) * gridStep;
                
                // Limit number of lines for better performance
                const xStepCount = Math.min(maxLines, Math.floor((xEnd - xStart) / gridStep));
                const yStepCount = Math.min(maxLines, Math.floor((yEnd - yStart) / gridStep));
                
                // Calculate adjusted step size to avoid too many lines
                const xStep = (xEnd - xStart) / xStepCount;
                const yStep = (yEnd - yStart) / yStepCount;
                
                // Draw grid lines with adjusted steps
                for (let i = 0; i <= xStepCount; i++) {
                    const xPos = xStart + i * xStep;
                    // Vertical line
                    const vLine = document.createElementNS(this.ns, 'line');
                    vLine.setAttribute('x1', xPos.toString());
                    vLine.setAttribute('y1', yStart.toString());
                    vLine.setAttribute('x2', xPos.toString());
                    vLine.setAttribute('y2', yEnd.toString());
                    vLine.setAttribute('stroke', '#444');
                    vLine.setAttribute('stroke-width', '0.1');
                    vLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    vLine.setAttribute('pointer-events', 'none'); // Each line is non-interactive
                    grid.appendChild(vLine);
                }
                
                for (let i = 0; i <= yStepCount; i++) {
                    const yPos = yStart + i * yStep;
                    // Horizontal line
                    const hLine = document.createElementNS(this.ns, 'line');
                    hLine.setAttribute('x1', xStart.toString());
                    hLine.setAttribute('y1', yPos.toString());
                    hLine.setAttribute('x2', xEnd.toString());
                    hLine.setAttribute('y2', yPos.toString());
                    hLine.setAttribute('stroke', '#444');
                    hLine.setAttribute('stroke-width', '0.1');
                    hLine.setAttribute('vector-effect', 'non-scaling-stroke');
                    hLine.setAttribute('pointer-events', 'none'); // Each line is non-interactive
                    grid.appendChild(hLine);
                }
                
                // Add thicker lines for axes
                const xAxis = document.createElementNS(this.ns, 'line');
                xAxis.setAttribute('x1', xStart.toString());
                xAxis.setAttribute('y1', '0');
                xAxis.setAttribute('x2', xEnd.toString());
                xAxis.setAttribute('y2', '0');
                xAxis.setAttribute('stroke', '#666');
                xAxis.setAttribute('stroke-width', '0.2');
                xAxis.setAttribute('vector-effect', 'non-scaling-stroke');
                xAxis.setAttribute('pointer-events', 'none'); // Non-interactive
                grid.appendChild(xAxis);
                
                const yAxis = document.createElementNS(this.ns, 'line');
                yAxis.setAttribute('x1', '0');
                yAxis.setAttribute('y1', yStart.toString());
                yAxis.setAttribute('x2', '0');
                yAxis.setAttribute('y2', yEnd.toString());
                yAxis.setAttribute('stroke', '#666');
                yAxis.setAttribute('stroke-width', '0.2');
                yAxis.setAttribute('vector-effect', 'non-scaling-stroke');
                yAxis.setAttribute('pointer-events', 'none'); // Non-interactive
                grid.appendChild(yAxis);
                
                // Update all canvas viewBoxes for consistency
                this.synchronizeViewBoxes(x, y, width, height);
                
                console.log(`Grid setup complete with ${xStepCount + 1} vertical and ${yStepCount + 1} horizontal lines`);
            }
            
            // Synchronize viewBoxes across all canvas layers
            synchronizeViewBoxes(x, y, width, height) {
                const viewBoxStr = `${x} ${y} ${width} ${height}`;
                
                // Apply the same viewBox to all layers
                this.gridCanvas.setAttribute('viewBox', viewBoxStr);
                this.editCanvas.setAttribute('viewBox', viewBoxStr);
                this.uiCanvas.setAttribute('viewBox', viewBoxStr);
                
                console.log(`Synchronized viewBox across all canvas layers: ${viewBoxStr}`);
            }
            
            // Simple setup methods to avoid errors
            setupEventListeners() {
                // Canvas interactions only (most reliable)
                if (this.editCanvas) {
                    this.editCanvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                    this.editCanvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                    this.editCanvas.addEventListener('mouseup', () => this.handleMouseUp());
                }
                
                // Add keyboard controls - use window-level event handling for reliability
                document.addEventListener('keydown', (e) => {
                    if (!this.selectedElement) return;
                    
                    // Don't handle key events if user is in a text field
                    if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;
                    
                    const step = e.shiftKey ? 5 : 1;
                    let dx = 0, dy = 0;
                    
                    // Handle arrow keys
                    switch (e.key) {
                        case 'ArrowLeft': dx = -step; break;
                        case 'ArrowRight': dx = step; break;
                        case 'ArrowUp': dy = -step; break;
                        case 'ArrowDown': dy = step; break;
                        default: return; // Exit if not an arrow key
                    }
                    
                    // Prevent default browser scrolling behavior
                    e.preventDefault();
                    
                    // Get current transform
                    let transform = this.selectedElement.getAttribute('transform') || '';
                    let translateX = 0, translateY = 0;
                    
                    // Extract translate values from current transform if it exists
                    const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                    if (translateMatch) {
                        translateX = parseFloat(translateMatch[1]);
                        translateY = parseFloat(translateMatch[2]);
                    }
                    
                    // Apply new translation
                    translateX += dx;
                    translateY += dy;
                    this.selectedElement.setAttribute('transform', `translate(${translateX},${translateY})`);
                    
                    // Update selection outline and handles
                    this.addSelectionOutline(this.selectedElement);
                    
                    // Update code view to reflect changes
                    this.updateCodeView();
                    
                    console.log(`Moved element with keyboard: dx=${dx}, dy=${dy}`);
                });
                
                // Safe event listener addition helper function
                const addListenerIfExists = (id, event, callback) => {
                    const element = document.getElementById(id);
                    if (element) {
                        element.addEventListener(event, callback);
                        return true;
                    }
                    return false;
                };
                
                // Basic tool selection
                document.querySelectorAll('.tool-button').forEach(btn => {
                    if (btn.id && btn.id.startsWith('tool-')) {
                        btn.addEventListener('click', () => {
                            this.setTool(btn.id.replace('tool-', ''));
                        });
                    }
                });
                
                // Set up zoom controls
                addListenerIfExists('zoom-in', 'click', () => this.zoomIn());
                addListenerIfExists('zoom-out', 'click', () => this.zoomOut());
                
                // Minimum essential functionality
                addListenerIfExists('delete-selected', 'click', () => this.deleteSelected());
                addListenerIfExists('apply-code', 'click', () => this.applyCodeChanges());
            }
            
            // Tool related methods
            setTool(tool) {
                // Update active tool
                document.querySelectorAll('.tool-button').forEach(btn => {
                    if (btn.id.startsWith('tool-')) {
                        btn.classList.remove('active');
                    }
                });
                
                const toolButton = document.getElementById(`tool-${tool}`);
                if (toolButton) {
                    toolButton.classList.add('active');
                }
                
                this.currentTool = tool;
                this.deselectElement();
            }
            
            // Selection methods
            selectElement(element) {
                this.deselectElement();
                
                if (element) {
                    this.selectedElement = element;
                    element.setAttribute('data-selected', 'true');
                    
                    // Highlight in tree view
                    if (this.treeContainer) {
                        const treeItems = this.treeContainer.querySelectorAll('.tree-item');
                        treeItems.forEach(item => {
                            item.classList.remove('selected');
                            if (item.dataset.nodeId === element.id) {
                                item.classList.add('selected');
                                // Ensure the selected item is visible by scrolling to it
                                item.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            }
                        });
                    }
                    
                    // Create selection outline
                    this.addSelectionOutline(element);
                    
                    this.updateCodeView();
                }
            }
            
            deselectElement() {
                if (this.selectedElement) {
                    this.selectedElement.removeAttribute('data-selected');
                    this.selectedElement = null;
                }
                
                // Remove selection outline and handles
                this.removeSelectionOutline();
                
                // Also clear point indicators
                this.clearPointIndicators();
            }
            
            addSelectionOutline(element) {
                this.removeSelectionOutline();
                
                try {
                    // Get the bounding box of the element
                    const bbox = element.getBBox();
                    
                    // Get element transform if any
                    const transform = element.getAttribute('transform') || '';
                    console.log(`Element transform: ${transform}`);
                    
                    // Create selection outline
                    this.selectionOutline = document.createElementNS(this.ns, 'rect');
                    this.selectionOutline.setAttribute('x', bbox.x - 2);
                    this.selectionOutline.setAttribute('y', bbox.y - 2);
                    this.selectionOutline.setAttribute('width', bbox.width + 4);
                    this.selectionOutline.setAttribute('height', bbox.height + 4);
                    this.selectionOutline.setAttribute('class', 'selection-outline');
                    
                    // Apply the same transform to the selection outline for correct positioning
                    if (transform) {
                        this.selectionOutline.setAttribute('transform', transform);
                    }
                    
                    // Add to point handles group (so it goes above content)
                    this.pointHandles.appendChild(this.selectionOutline);
                    
                    // Add drag handles at corners
                    this.addDragHandles(bbox, transform);
                    
                    console.log("Added selection outline");
                } catch (e) {
                    console.error("Error adding selection outline:", e);
                }
            }
            
            removeSelectionOutline() {
                // Remove selection outline
                if (this.selectionOutline && this.selectionOutline.parentNode) {
                    this.selectionOutline.parentNode.removeChild(this.selectionOutline);
                    this.selectionOutline = null;
                }
                
                // Remove drag handles
                this.dragHandles.forEach(handle => {
                    if (handle.parentNode) {
                        handle.parentNode.removeChild(handle);
                    }
                });
                this.dragHandles = [];
            }
            
            addDragHandles(bbox, transform = '') {
                // Size calculation based on the viewBox, not zoom level
                const viewBox = this.editCanvas.viewBox.baseVal;
                const viewBoxWidth = viewBox.width;
                const viewBoxHeight = viewBox.height;
                
                // Calculate handle size relative to content size (0.5% to 2% of viewBox)
                const baseSize = Math.min(viewBoxWidth, viewBoxHeight) * 0.01;
                
                // Keep size within reasonable bounds (SVG coordinate units)
                const minSize = 0.5; // Minimum size in SVG units
                const maxSize = 2;   // Maximum size in SVG units
                const handleSize = Math.max(minSize, Math.min(maxSize, baseSize));
                
                console.log(`Creating handles with size: ${handleSize} (viewBox: ${viewBoxWidth}x${viewBoxHeight})`);
                
                const handlePositions = [
                    { x: bbox.x - handleSize/2, y: bbox.y - handleSize/2, cursor: 'nw-resize', corner: 'nw' },
                    { x: bbox.x + bbox.width - handleSize/2, y: bbox.y - handleSize/2, cursor: 'ne-resize', corner: 'ne' },
                    { x: bbox.x - handleSize/2, y: bbox.y + bbox.height - handleSize/2, cursor: 'sw-resize', corner: 'sw' },
                    { x: bbox.x + bbox.width - handleSize/2, y: bbox.y + bbox.height - handleSize/2, cursor: 'se-resize', corner: 'se' },
                    { x: bbox.x + bbox.width/2 - handleSize/2, y: bbox.y - handleSize/2, cursor: 'n-resize', corner: 'n' },
                    { x: bbox.x + bbox.width - handleSize/2, y: bbox.y + bbox.height/2 - handleSize/2, cursor: 'e-resize', corner: 'e' },
                    { x: bbox.x + bbox.width/2 - handleSize/2, y: bbox.y + bbox.height - handleSize/2, cursor: 's-resize', corner: 's' },
                    { x: bbox.x - handleSize/2, y: bbox.y + bbox.height/2 - handleSize/2, cursor: 'w-resize', corner: 'w' }
                ];
                
                handlePositions.forEach(pos => {
                    const handle = document.createElementNS(this.ns, 'rect');
                    handle.setAttribute('x', pos.x);
                    handle.setAttribute('y', pos.y);
                    handle.setAttribute('width', handleSize);
                    handle.setAttribute('height', handleSize);
                    handle.setAttribute('class', 'drag-handle');
                    handle.style.cursor = pos.cursor;
                    handle.dataset.corner = pos.corner;
                    
                    // Apply same transform as the element for correct positioning
                    if (transform) {
                        handle.setAttribute('transform', transform);
                    }
                    
                    handle.addEventListener('mousedown', (e) => {
                        e.stopPropagation();
                        this.startResize(e, pos.corner);
                    });
                    
                    this.pointHandles.appendChild(handle);
                    this.dragHandles.push(handle);
                });
                
                // Add center drag handle
                const centerSize = handleSize * 1.4; // Slightly larger center handle
                const centerHandle = document.createElementNS(this.ns, 'rect');
                centerHandle.setAttribute('x', bbox.x + bbox.width/2 - centerSize/2);
                centerHandle.setAttribute('y', bbox.y + bbox.height/2 - centerSize/2);
                centerHandle.setAttribute('width', centerSize);
                centerHandle.setAttribute('height', centerSize);
                centerHandle.setAttribute('class', 'drag-handle');
                centerHandle.style.cursor = 'move';
                
                // Apply same transform as the element for correct positioning
                if (transform) {
                    centerHandle.setAttribute('transform', transform);
                }
                
                centerHandle.addEventListener('mousedown', (e) => {
                    e.stopPropagation();
                    this.startDrag(e);
                });
                
                this.pointHandles.appendChild(centerHandle);
                this.dragHandles.push(centerHandle);
            }
            
            // Basic mouse handlers
            handleMouseDown(e) {
                if (this.currentTool === 'select') {
                    const target = e.target;
                    // Ignore if it's a handle, canvas, or grid
                    if (target.classList.contains('drag-handle') || 
                        target.tagName === 'svg' || 
                        target.id === 'grid' || 
                        target.id === 'content' ||
                        target.id === 'point-handles') {
                        
                        if (target.tagName === 'svg' || target.id === 'grid' || target.id === 'content' || target.id === 'point-handles') {
                            this.deselectElement();
                            // Also clear any point indicators when clicking on background
                            this.clearPointIndicators();
                        }
                        return;
                    }
                    
                    // If not already selected, select the element
                    if (target !== this.selectedElement) {
                        this.selectElement(target);
                    }
                    
                    // Start drag operation
                    this.startDrag(e);
                }
            }
            
            // Simple placeholder for mouse move/up that weren't fully replaced
            handleMouseMove(e) {
                // Mouse move is handled by the drag move handler when dragging
                if (!this.dragState) {
                    // Implement hover effects or other non-drag interactions here
                }
            }
            
            handleMouseUp(e) {
                // Mouse up is handled by the drag end handler when dragging
                if (!this.dragState) {
                    // Handle non-drag mouse up events here
                }
            }
            
            startDrag(e) {
                if (!this.selectedElement) return;
                
                // Get current mouse position relative to SVG
                const svgPoint = this.getSVGPoint(e);
                const scale = this.zoom / 100;
                
                // Get current element position
                let transform = this.selectedElement.getAttribute('transform') || '';
                let translateX = 0;
                let translateY = 0;
                
                // Extract translate values from current transform if it exists
                const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                if (translateMatch) {
                    translateX = parseFloat(translateMatch[1]);
                    translateY = parseFloat(translateMatch[2]);
                }
                
                // Setup drag state
                this.dragState = {
                    element: this.selectedElement,
                    startX: svgPoint.x,
                    startY: svgPoint.y,
                    currentTranslateX: translateX,
                    currentTranslateY: translateY,
                    scale: scale,
                    type: 'move'
                };
                
                // Add event listeners for drag
                document.addEventListener('mousemove', this.handleDragMove);
                document.addEventListener('mouseup', this.handleDragEnd);
            }
            
            startResize(e, corner) {
                if (!this.selectedElement) return;
                
                // Get current mouse position relative to SVG
                const svgPoint = this.getSVGPoint(e);
                
                // Get element's bounding box
                const bbox = this.selectedElement.getBBox();
                
                // Get current transform
                let transform = this.selectedElement.getAttribute('transform') || '';
                let translateX = 0;
                let translateY = 0;
                
                // Extract translate values from current transform if it exists
                const translateMatch = transform.match(/translate\(([^,]+),([^)]+)\)/);
                if (translateMatch) {
                    translateX = parseFloat(translateMatch[1]);
                    translateY = parseFloat(translateMatch[2]);
                }
                
                // Setup drag state for resize
                this.dragState = {
                    element: this.selectedElement,
                    startX: svgPoint.x,
                    startY: svgPoint.y,
                    originalBBox: bbox,
                    corner: corner,
                    originalTranslateX: translateX,
                    originalTranslateY: translateY,
                    type: 'resize'
                };
                
                // Add event listeners for resize
                document.addEventListener('mousemove', this.handleDragMove);
                document.addEventListener('mouseup', this.handleDragEnd);
                
                console.log(`Starting resize from corner: ${corner}`);
            }
            
            handleDragMove(e) {
                if (!this.dragState) return;
                
                // Get current mouse position
                const svgPoint = this.getSVGPoint(e);
                
                if (this.dragState.type === 'move') {
                    // Calculate difference from start position
                    const dx = svgPoint.x - this.dragState.startX;
                    const dy = svgPoint.y - this.dragState.startY;
                    
                    // Apply new translate transform
                    const newTranslateX = this.dragState.currentTranslateX + dx;
                    const newTranslateY = this.dragState.currentTranslateY + dy;
                    
                    // Update element transform
                    const transform = `translate(${newTranslateX},${newTranslateY})`;
                    this.dragState.element.setAttribute('transform', transform);
                    
                    // Update selection outline transform without recreating it
                    if (this.selectionOutline) {
                        this.selectionOutline.setAttribute('transform', transform);
                        
                        // Update handles with same transform
                        this.dragHandles.forEach(handle => {
                            handle.setAttribute('transform', transform);
                        });
                    }
                } else if (this.dragState.type === 'resize') {
                    // Calculate the current delta
                    const dx = svgPoint.x - this.dragState.startX;
                    const dy = svgPoint.y - this.dragState.startY;
                    
                    // Get original bbox
                    const bbox = this.dragState.originalBBox;
                    
                    // Create variables for the new dimensions
                    let newX = bbox.x;
                    let newY = bbox.y;
                    let newWidth = bbox.width;
                    let newHeight = bbox.height;
                    
                    // Handle different resize corners
                    const corner = this.dragState.corner;
                    
                    switch (corner) {
                        case 'nw': // Northwest
                            newX = bbox.x + dx;
                            newY = bbox.y + dy;
                            newWidth = bbox.width - dx;
                            newHeight = bbox.height - dy;
                            break;
                        case 'ne': // Northeast
                            newY = bbox.y + dy;
                            newWidth = bbox.width + dx;
                            newHeight = bbox.height - dy;
                            break;
                        case 'sw': // Southwest
                            newX = bbox.x + dx;
                            newWidth = bbox.width - dx;
                            newHeight = bbox.height + dy;
                            break;
                        case 'se': // Southeast
                            newWidth = bbox.width + dx;
                            newHeight = bbox.height + dy;
                            break;
                        case 'n': // North
                            newY = bbox.y + dy;
                            newHeight = bbox.height - dy;
                            break;
                        case 'e': // East
                            newWidth = bbox.width + dx;
                            break;
                        case 's': // South
                            newHeight = bbox.height + dy;
                            break;
                        case 'w': // West
                            newX = bbox.x + dx;
                            newWidth = bbox.width - dx;
                            break;
                    }
                    
                    // Ensure minimum dimensions
                    if (newWidth < 0.5) newWidth = 0.5;
                    if (newHeight < 0.5) newHeight = 0.5;
                    
                    // We'll use a simplified approach for all elements: apply a transform
                    // This is less precise but more robust across different SVG elements
                    
                    // Calculate scale factors
                    const scaleX = newWidth / bbox.width;
                    const scaleY = newHeight / bbox.height;
                    
                    // Calculate the translation needed to position correctly after scaling
                    const translateX = this.dragState.originalTranslateX + (newX - bbox.x);
                    const translateY = this.dragState.originalTranslateY + (newY - bbox.y);
                    
                    // Apply transform to the element
                    const transform = `translate(${translateX},${translateY}) scale(${scaleX},${scaleY})`;
                    this.dragState.element.setAttribute('transform', transform);
                    
                    // Update selection outline and handles by recreating them
                    // This is more reliable than trying to transform them
                    this.addSelectionOutline(this.dragState.element);
                    
                    console.log(`Resizing to: x=${newX}, y=${newY}, w=${newWidth}, h=${newHeight}, transform=${transform}`);
                }
            }
            
            handleDragEnd() {
                // Remove event listeners
                document.removeEventListener('mousemove', this.handleDragMove);
                document.removeEventListener('mouseup', this.handleDragEnd);
                
                // Reset drag state
                this.dragState = null;
                
                // Update code view with new position
                this.updateCodeView();
            }
            
            // Helper to get SVG coordinates from mouse event
            getSVGPoint(evt) {
                const canvas = this.editCanvas;
                const pt = canvas.createSVGPoint();
                pt.x = evt.clientX;
                pt.y = evt.clientY;
                
                // Convert to SVG coordinate space
                const svgPoint = pt.matrixTransform(canvas.getScreenCTM().inverse());
                return svgPoint;
            }
            
            // Element modification methods
            deleteSelected() {
                if (this.selectedElement && this.selectedElement.parentNode) {
                    this.selectedElement.parentNode.removeChild(this.selectedElement);
                    this.selectedElement = null;
                    this.updateCodeView();
                    this.updateObjectTree();
                }
            }
            
            // Code view methods
            updateCodeView() {
                if (!this.codeView) return;
                
                let svgContent = '';
                const children = this.content.childNodes;
                
                for (let i = 0; i < children.length; i++) {
                    const node = children[i];
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        svgContent += node.outerHTML + '\n';
                    }
                }
                
                this.codeView.value = svgContent;
            }
            
            applyCodeChanges() {
                if (!this.codeView) return;
                
                const tempContainer = document.createElementNS(this.ns, 'div');
                tempContainer.innerHTML = this.codeView.value;
                
                // Clear content
                while (this.content.firstChild) {
                    this.content.removeChild(this.content.firstChild);
                }
                
                // Add new elements
                const nodes = tempContainer.childNodes;
                for (let i = 0; i < nodes.length; i++) {
                    const node = nodes[i];
                    if (node.nodeType === Node.ELEMENT_NODE) {
                        this.content.appendChild(document.importNode(node, true));
                    }
                }
                
                this.updateObjectTree();
            }
            
            setupCodeEditor() {
                if (!this.codeView) return;
                
                this.codeView.addEventListener('input', () => {
                    // Simple update - no debounce for simplicity
                    this.applyCodeChanges();
                });
            }
            
            // Object tree methods
            updateObjectTree() {
                if (!this.treeContainer) {
                    console.warn("Tree container not found, skipping object tree update");
                    return;
                }
                
                try {
                    // Clear tree
                    this.treeContainer.innerHTML = '';
                    
                    if (!this.content || !this.content.childNodes || this.content.childNodes.length === 0) {
                        console.log("No content to display in tree");
                        const emptyMessage = document.createElement('div');
                        emptyMessage.className = 'empty-message';
                        emptyMessage.textContent = 'No SVG elements';
                        emptyMessage.style.padding = '10px';
                        emptyMessage.style.color = '#aaa';
                        this.treeContainer.appendChild(emptyMessage);
                        return;
                    }
                    
                    console.log("Building tree items for", this.content.childNodes.length, "nodes");
                    
                    // Build tree
                    this.buildTreeItems(this.content, this.treeContainer);
                    console.log("Object tree updated");
                } catch (e) {
                    console.error("Error updating object tree:", e);
                }
            }
            
            buildTreeItems(parentElement, container) {
                try {
                    if (!parentElement || !container) {
                        console.warn("Invalid parameters for buildTreeItems");
                        return;
                    }
                    
                    const children = parentElement.childNodes;
                    let itemCount = 0;
                    
                    // First pass: collect comments and associate with following nodes
                    const commentMap = new Map();
                    let lastComment = null;
                    
                    for (let i = 0; i < children.length; i++) {
                        const node = children[i];
                        
                        if (node.nodeType === Node.COMMENT_NODE) {
                            lastComment = node.textContent.trim();
                            // Check if next node is an element and associate the comment
                            if (i + 1 < children.length && children[i + 1].nodeType === Node.ELEMENT_NODE) {
                                commentMap.set(children[i + 1], lastComment);
                            }
                        } else if (node.nodeType === Node.ELEMENT_NODE && lastComment && !commentMap.has(node)) {
                            // Also associate with current element if no other element has taken this comment
                            commentMap.set(node, lastComment);
                            lastComment = null; // Clear so we don't apply to multiple elements
                        }
                    }
                    
                    console.log(`Found ${commentMap.size} comments for tree items`);
                    
                    // Second pass: build tree items
                    for (let i = 0; i < children.length; i++) {
                        const node = children[i];
                        if (node.nodeType === Node.ELEMENT_NODE) {
                            itemCount++;
                            
                            const treeItem = document.createElement('div');
                            treeItem.className = 'tree-item';
                            
                            // Ensure element has an ID for reference
                            if (!node.id) {
                                node.id = `node-${Math.random().toString(36).substring(2, 9)}`;
                            }
                            treeItem.dataset.nodeId = node.id;
                            
                            // Apply selection if this is the selected element
                            if (node === this.selectedElement) {
                                treeItem.classList.add('selected');
                            }
                            
                            // Get comment or determine element name
                            const comment = commentMap.get(node);
                            const nodeName = node.nodeName.toLowerCase();
                            
                            // Final display name with priority:
                            // 1. Comment if available
                            // 2. ID-based name if ID exists
                            // 3. Node type with distinctive property
                            let displayName;
                            
                            if (comment) {
                                displayName = comment;
                            } else {
                                displayName = this.generateElementName(node);
                            }
                            
                            // Add element-type specific class for styling
                            treeItem.classList.add(`item-${nodeName}`);
                            
                            // Create content container
                            const itemContent = document.createElement('div');
                            itemContent.className = 'tree-item-content';
                            
                            // Add name with icon for element type
                            const itemName = document.createElement('div');
                            itemName.className = 'tree-item-name';
                            itemName.textContent = displayName;
                            itemContent.appendChild(itemName);
                            
                            // For complex elements (SVG groups) add more description
                            if (nodeName === 'g' || nodeName === 'svg') {
                                const childCount = node.children.length;
                                if (childCount > 0) {
                                    const itemDesc = document.createElement('div');
                                    itemDesc.className = 'tree-item-attrs';
                                    itemDesc.textContent = `${childCount} child element${childCount !== 1 ? 's' : ''}`;
                                    itemContent.appendChild(itemDesc);
                                }
                            } else if (nodeName === 'path' && node.hasAttribute('d')) {
                                // Show truncated path data
                                const pathData = node.getAttribute('d');
                                if (pathData.length > 30) {
                                    const itemDesc = document.createElement('div');
                                    itemDesc.className = 'tree-item-attrs';
                                    itemDesc.textContent = `d="${pathData.substring(0, 30)}..."`;
                                    itemContent.appendChild(itemDesc);
                                }
                            }
                            
                            // Add icon based on element type
                            const itemIcon = document.createElement('span');
                            itemIcon.className = 'tree-item-icon';
                            switch (nodeName) {
                                case 'path':
                                    itemIcon.innerHTML = 'â';
                                    itemIcon.title = 'Path';
                                    break;
                                case 'rect':
                                    itemIcon.innerHTML = 'â¡';
                                    itemIcon.title = 'Rectangle';
                                    break;
                                case 'circle':
                                    itemIcon.innerHTML = 'â';
                                    itemIcon.title = 'Circle';
                                    break;
                                case 'g':
                                    itemIcon.innerHTML = 'â';
                                    itemIcon.title = 'Group';
                                    break;
                                default:
                                    itemIcon.innerHTML = 'â¬¦';
                                    itemIcon.title = nodeName;
                            }
                            
                            // Process children first to determine if we need expand icon
                            let childContainer = null;
                            if (node.childElementCount > 0) {
                                childContainer = document.createElement('div');
                                childContainer.className = 'child-items';
                                const childCount = this.buildTreeItems(node, childContainer);
                                
                                if (childCount > 0) {
                                    const expandIcon = document.createElement('span');
                                    expandIcon.className = 'expand-icon';
                                    expandIcon.innerHTML = 'â¼';
                                    treeItem.appendChild(expandIcon);
                                    
                                    expandIcon.addEventListener('click', (e) => {
                                        e.stopPropagation();
                                        if (childContainer.style.display === 'none') {
                                            childContainer.style.display = 'block';
                                            expandIcon.innerHTML = 'â¼';
                                        } else {
                                            childContainer.style.display = 'none';
                                            expandIcon.innerHTML = 'âº';
                                        }
                                    });
                                }
                            }
                            
                            treeItem.appendChild(itemIcon);
                            treeItem.appendChild(itemContent);
                            
                            // Add points toggle for path elements
                            if (nodeName === 'path' && node.hasAttribute('d')) {
                                const pointsToggle = document.createElement('span');
                                pointsToggle.className = 'points-toggle';
                                pointsToggle.textContent = 'show points';
                                pointsToggle.title = 'Toggle points view';
                                
                                pointsToggle.addEventListener('click', (e) => {
                                    e.stopPropagation();
                                    this.togglePointsList(node, treeItem);
                                });
                                
                                itemContent.appendChild(pointsToggle);
                            }
                            
                            // Create info button for element
                            const nodeIdBtn = document.createElement('button');
                            nodeIdBtn.className = 'node-id-btn';
                            nodeIdBtn.title = `Node ID: ${node.id}`;
                            nodeIdBtn.innerHTML = 'â¹';
                            nodeIdBtn.style.marginLeft = '4px';
                            nodeIdBtn.style.fontSize = '10px';
                            nodeIdBtn.style.padding = '2px 4px';
                            nodeIdBtn.style.background = 'rgba(255,255,255,0.1)';
                            nodeIdBtn.style.border = 'none';
                            nodeIdBtn.style.borderRadius = '3px';
                            nodeIdBtn.style.color = '#888';
                            
                            nodeIdBtn.addEventListener('click', (e) => {
                                e.stopPropagation();
                                alert(`Element ID: ${node.id}\nType: ${nodeName}`);
                            });
                            
                            itemContent.appendChild(nodeIdBtn);
                            
                            // Add element selection
                            treeItem.addEventListener('click', () => {
                                this.selectElement(node);
                            });
                            
                            container.appendChild(treeItem);
                            if (childContainer && childContainer.childNodes.length > 0) {
                                container.appendChild(childContainer);
                            }
                        }
                    }
                    
                    return itemCount;
                } catch (e) {
                    console.error("Error building tree items:", e);
                    return 0;
                }
            }
            
            // Helper method to generate descriptive element names
            generateElementName(element) {
                const nodeName = element.nodeName.toLowerCase();
                if (element.hasAttribute('id')) {
                    return `${nodeName} #${element.id}`;
                }
                if (element.hasAttribute('class')) {
                    return `${nodeName} .${element.getAttribute('class')}`;
                }
                return nodeName;
            }
            
            // Toggle points list for path elements
            togglePointsList(pathElement, treeItem) {
                try {
                    // Get the path data
                    const pathData = pathElement.getAttribute('d');
                    if (!pathData) {
                        console.warn("Path has no 'd' attribute");
                        return;
                    }
                    
                    // Find or create points container
                    let pointsContainer = treeItem.querySelector('.points-container');
                    
                    // If container exists, toggle visibility
                    if (pointsContainer) {
                        const isVisible = pointsContainer.style.display !== 'none';
                        pointsContainer.style.display = isVisible ? 'none' : 'block';
                        
                        // Update the points toggle text
                        const pointsToggle = treeItem.querySelector('.points-toggle');
                        if (pointsToggle) {
                            pointsToggle.textContent = isVisible ? 'show points' : 'hide points';
                        }
                        
                        if (!isVisible) {
                            // If showing, make sure points are up to date
                            this.buildPointsList(pathElement, pointsContainer);
                        }
                    } else {
                        // Create and add points container
                        pointsContainer = document.createElement('div');
                        pointsContainer.className = 'points-container';
                        treeItem.appendChild(pointsContainer);
                        
                        // Build points list
                        this.buildPointsList(pathElement, pointsContainer);
                        
                        // Update toggle text
                        const pointsToggle = treeItem.querySelector('.points-toggle');
                        if (pointsToggle) {
                            pointsToggle.textContent = 'hide points';
                        }
                    }
                } catch (e) {
                    console.error("Error toggling points list:", e);
                }
            }
            
            // Build points list for path elements
            buildPointsList(pathElement, container) {
                try {
                    container.innerHTML = '';
                    
                    const pathData = pathElement.getAttribute('d');
                    if (!pathData) return;
                    
                    console.log(`Building points list for path data: ${pathData}`);
                    
                    // Simple path parser - won't handle all cases but works for basic paths
                    const commands = pathData.match(/[a-zA-Z][^a-zA-Z]*/g) || [];
                    
                    if (commands.length === 0) {
                        const emptyMsg = document.createElement('div');
                        emptyMsg.className = 'point-item';
                        emptyMsg.textContent = 'No parsable points';
                        container.appendChild(emptyMsg);
                        return;
                    }
                    
                    let pointIndex = 1; // Start from 1 instead of 0
                    
                    // Add header for points
                    const header = document.createElement('div');
                    header.className = 'points-header';
                    header.textContent = `${commands.length} points:`;
                    header.style.fontSize = '11px';
                    header.style.marginBottom = '5px';
                    header.style.color = '#aaa';
                    container.appendChild(header);
                    
                    for (const cmd of commands) {
                        const type = cmd[0].toUpperCase();
                        const params = cmd.substring(1).trim().split(/[\s,]+/).filter(p => p.length > 0);
                        
                        // Only create point items for actual points (M and L commands)
                        if (type === 'M' || type === 'L') {
                            const pointItem = document.createElement('div');
                            pointItem.className = 'point-item';
                            pointItem.textContent = `Point ${pointIndex}: (${params[0]},${params[1]})`;
                            
                            // Add point type
                            const pointType = document.createElement('span');
                            pointType.className = 'point-type';
                            pointType.textContent = type === 'M' ? 'start' : 'line';
                            pointItem.appendChild(pointType);
                            
                            // Store coordinates for selection
                            pointItem.dataset.x = params[0];
                            pointItem.dataset.y = params[1];
                            pointItem.dataset.type = type;
                            pointItem.dataset.index = pointIndex - 1; // Store zero-based index
                            
                            // Add click handler to highlight point
                            pointItem.addEventListener('click', (e) => {
                                e.stopPropagation();
                                
                                // Remove selection from other points
                                container.querySelectorAll('.point-item').forEach(p => p.classList.remove('selected'));
                                
                                // Add selection to this point
                                pointItem.classList.add('selected');
                                
                                // Show point indicator
                                this.showPointIndicator(parseFloat(params[0]), parseFloat(params[1]), pathElement);
                                
                                // Select the parent path if not already selected
                                if (this.selectedElement !== pathElement) {
                                    this.selectElement(pathElement);
                                }
                            });
                            
                            container.appendChild(pointItem);
                            pointIndex++;
                        } else if (type === 'Z' || type === 'z') {
                            // Special handling for path close command
                            const closeItem = document.createElement('div');
                            closeItem.className = 'point-item path-close';
                            closeItem.textContent = `Close path`;
                            closeItem.style.fontStyle = 'italic';
                            closeItem.style.color = '#999';
                            container.appendChild(closeItem);
                        }
                    }
                } catch (e) {
                    console.error("Error building points list:", e);
                    
                    const errorMsg = document.createElement('div');
                    errorMsg.className = 'point-item';
                    errorMsg.textContent = 'Error parsing path data';
                    errorMsg.style.color = '#ff6b6b';
                    container.appendChild(errorMsg);
                }
            }
            
            // Show a point indicator at the specified coordinates
            showPointIndicator(x, y, pathElement) {
                try {
                    // Clear existing indicators first
                    this.clearPointIndicators();
                    
                    // Create a new indicator
                    const indicator = document.createElementNS(this.ns, 'circle');
                    indicator.setAttribute('cx', x);
                    indicator.setAttribute('cy', y);
                    indicator.setAttribute('class', 'point-indicator');
                    
                    // If we have the path element, apply the same transform to the indicator
                    if (pathElement && pathElement.hasAttribute('transform')) {
                        const transform = pathElement.getAttribute('transform');
                        indicator.setAttribute('transform', transform);
                        console.log(`Applied transform ${transform} to point indicator`);
                    }
                    
                    this.pointHandles.appendChild(indicator);
                    
                    console.log(`Point indicator added at (${x}, ${y})`);
                } catch (e) {
                    console.error("Error showing point indicator:", e);
                }
            }
            
            // SVG content methods
            setSvgString(svgString) {
                console.log("Setting SVG content...");
                try {
                    // Clean up the SVG string first to fix common issues
                    svgString = this.cleanSvgString(svgString);
                    
                    // Clear current content
                    while (this.content.firstChild) {
                        this.content.removeChild(this.content.firstChild);
                    }
                    
                    // Create and setup content correctly
                    const parser = new DOMParser();
                    let doc;
                    
                    // First try parsing as an SVG document
                    try {
                        doc = parser.parseFromString(`<svg xmlns="${this.ns}">${svgString}</svg>`, "image/svg+xml");
                        console.log("Parsed SVG document");
                    } catch (e) {
                        console.error("Error parsing SVG with namespace", e);
                        // Fallback to HTML parsing
                        doc = parser.parseFromString(`<div>${svgString}</div>`, "text/html");
                        console.log("Parsed as HTML instead");
                    }
                    
                    // Import the content
                    if (doc.querySelector('svg')) {
                        // Import from SVG wrapper
                        const nodes = doc.querySelector('svg').childNodes;
                        console.log(`Found ${nodes.length} nodes in SVG document`);
                        
                        for (let i = 0; i < nodes.length; i++) {
                            if (nodes[i].nodeType === Node.ELEMENT_NODE) {
                                const imported = document.importNode(nodes[i], true);
                                this.content.appendChild(imported);
                                console.log(`Imported SVG element: ${imported.nodeName}`);
                            }
                        }
                    } else {
                        // Import from HTML wrapper (direct content)
                        const wrapper = doc.body || doc.querySelector('div');
                        if (wrapper) {
                            const elements = wrapper.children;
                            console.log(`Found ${elements.length} elements in wrapper`);
                            
                            for (let i = 0; i < elements.length; i++) {
                                if (elements[i].nodeType === Node.ELEMENT_NODE) {
                                    const imported = document.importNode(elements[i], true);
                                    this.content.appendChild(imported);
                                    console.log(`Imported direct element: ${imported.nodeName}`);
                                }
                            }
                        } else {
                            console.warn("No wrapper found for content");
                        }
                    }
                    
                    // Check if content was added
                    if (this.content.children.length === 0) {
                        console.warn("No elements were imported, trying direct innerHTML as fallback");
                        // Last resort - try direct innerHTML with cleaned content
                        this.content.innerHTML = svgString;
                    }
                    
                    // Make sure content is visible - debug viewBox
                    console.log(`Current viewBox: ${this.editCanvas.getAttribute('viewBox')}`);
                    
                    // Force a repaint of the container
                    const container = document.getElementById('canvas-container');
                    if (container) {
                        container.style.display = 'none';
                        container.offsetHeight; // Trigger reflow
                        container.style.display = 'flex';
                    }
                    
                    // Update UI
                    setTimeout(() => {
                        try {
                            this.updateCodeView();
                            this.updateObjectTree();
                            console.log("UI updated after content set");
                            
                            // Ensure SVG is visible by centering and adjusting viewBox if needed
                            this.adjustViewBox();
                        } catch (e) {
                            console.error("Error updating UI after setting content:", e);
                        }
                    }, 100);
                    
                    console.log("SVG content set successfully");
                } catch (e) {
                    console.error("Error setting SVG content:", e);
                }
            }
            
            // Helper method to clean SVG string
            cleanSvgString(svgString) {
                if (!svgString) return '';
                
                console.log("Cleaning SVG string");
                
                // Fix malformed nested closing tags
                svgString = svgString.replace(/<\/path><\/path>/g, '</path>');
                
                // Fix incomplete tags
                svgString = svgString.replace(/<path([^>]*)>([^<]*)<\/path>/g, (match, attrs, content) => {
                    // If content contains another opening tag but no closing tag
                    if (content.includes('<path') && !content.includes('</path>')) {
                        return `<path${attrs}>${content.replace(/<path/g, '</path><path')}`;
                    }
                    return match;
                });
                
                // Handle unclosed tags
                const openTags = [];
                const tagRegex = /<(\/?)(path|g|rect|circle|ellipse|line|polyline|polygon|text)([^>]*)>/g;
                let lastIndex = 0;
                let result = '';
                let match;
                
                while ((match = tagRegex.exec(svgString)) !== null) {
                    const fullTag = match[0];
                    const isClosing = match[1] === '/';
                    const tagName = match[2];
                    
                    result += svgString.substring(lastIndex, match.index);
                    
                    if (isClosing) {
                        // Check if this closing tag matches the last opened tag
                        if (openTags.length > 0 && openTags[openTags.length - 1] === tagName) {
                            openTags.pop();
                            result += fullTag;
                        } else {
                            // Skip unmatched closing tag
                            console.warn(`Skipping unmatched closing tag: ${fullTag}`);
                        }
                    } else {
                        // Self-closing tags
                        if (fullTag.endsWith('/>')) {
                            result += fullTag;
                        } else {
                            openTags.push(tagName);
                            result += fullTag;
                        }
                    }
                    
                    lastIndex = tagRegex.lastIndex;
                }
                
                // Add the remaining content
                result += svgString.substring(lastIndex);
                
                // Close any tags that were not properly closed
                for (let i = openTags.length - 1; i >= 0; i--) {
                    result += `</${openTags[i]}>`;
                    console.warn(`Added missing closing tag: </${openTags[i]}>`);
                }
                
                console.log("Cleaned SVG string:", result.substring(0, 100) + "...");
                return result;
            }
            
            // Adjust viewBox to ensure content is visible
            adjustViewBox() {
                try {
                    let bbox;
                    
                    try {
                        // Get bounding box from actual content
                        bbox = this.content.getBBox();
                    } catch (e) {
                        console.warn("Could not get bounding box of content:", e);
                        
                        // Fall back to a reasonable default
                        this.synchronizeViewBoxes(-50, -50, 100, 100);
                        return;
                    }
                    
                    if (!bbox || (bbox.width === 0 && bbox.height === 0)) {
                        console.warn("Empty bounding box, using default viewBox");
                        this.synchronizeViewBoxes(-50, -50, 100, 100);
                        return;
                    }
                    
                    console.log(`Content bounding box: x=${bbox.x}, y=${bbox.y}, width=${bbox.width}, height=${bbox.height}`);
                    
                    // Ensure minimum content size for padding calculation
                    // Beak elements can be very tiny (single-digit units)
                    const effectiveWidth = Math.max(bbox.width, 10);
                    const effectiveHeight = Math.max(bbox.height, 10);
                    const maxDimension = Math.max(effectiveWidth, effectiveHeight);
                    
                    // Calculate padding for different sizes
                    let paddingRatio;
                    if (maxDimension < 20) {
                        paddingRatio = 2.0; // 200% padding for small objects
                    } else {
                        paddingRatio = 0.5; // 50% padding for larger objects
                    }
                    
                    const padding = maxDimension * paddingRatio;
                    
                    // Ensure minimum viewBox size
                    const minViewBoxDimension = 40; // Reasonable minimum size
                    
                    // Calculate dimensions with padding
                    let width = Math.max(minViewBoxDimension, bbox.width + padding * 2);
                    let height = Math.max(minViewBoxDimension, bbox.height + padding * 2);
                    let x = bbox.x - padding;
                    let y = bbox.y - padding;
                    
                    // Maintain aspect ratio
                    const containerAspect = this.editCanvas.clientWidth / this.editCanvas.clientHeight;
                    const contentAspect = width / height;
                    
                    if (containerAspect > contentAspect) {
                        // Container is wider than content - extend width
                        const newWidth = height * containerAspect;
                        x -= (newWidth - width) / 2;
                        width = newWidth;
                    } else {
                        // Container is taller than content - extend height
                        const newHeight = width / containerAspect;
                        y -= (newHeight - height) / 2;
                        height = newHeight;
                    }
                    
                    // Apply to all canvas layers
                    this.synchronizeViewBoxes(x, y, width, height);
                    
                    // Reset zoom to 100%
                    this.zoom = 100;
                    
                    // Update zoom display
                    const zoomValue = document.getElementById('zoom-value');
                    if (zoomValue) {
                        zoomValue.textContent = `${this.zoom}%`;
                    }
                    
                    // Update grid to match
                    this.setupGrid(x, y, width, height);
                    
                    console.log(`ViewBox adjusted: x=${x}, y=${y}, width=${width}, height=${height} with ${paddingRatio * 100}% padding`);
                } catch (e) {
                    console.error("Error adjusting viewBox:", e);
                    this.synchronizeViewBoxes(-50, -50, 100, 100); // Fallback
                }
            }
            
            // Zoom methods
            zoomIn() {
                this.setZoom(this.zoom + 20);
            }
            
            zoomOut() {
                this.setZoom(this.zoom - 20);
            }
            
            setZoom(zoomLevel) {
                // Limit zoom between
                const minZoom = 20;
                const maxZoom = 500;
                this.zoom = Math.min(maxZoom, Math.max(minZoom, zoomLevel));
                
                // Update display
                const zoomValue = document.getElementById('zoom-value');
                if (zoomValue) {
                    zoomValue.textContent = `${this.zoom}%`;
                }
                
                // Get current viewBox
                const vb = this.editCanvas.viewBox.baseVal;
                
                // Get the center point of the current viewBox
                const centerX = vb.x + vb.width / 2;
                const centerY = vb.y + vb.height / 2;
                
                // Calculate new dimensions based on zoom
                const scale = 100 / this.zoom;
                const newWidth = vb.width * scale;
                const newHeight = vb.height * scale;
                
                // Calculate new origin to maintain the center point
                const newX = centerX - newWidth / 2;
                const newY = centerY - newHeight / 2;
                
                // Apply the new viewBox to all canvases
                this.synchronizeViewBoxes(newX, newY, newWidth, newHeight);
                
                // Update grid with new viewBox
                this.setupGrid(newX, newY, newWidth, newHeight);
                
                // Update UI elements to maintain visual size with new viewBox
                if (this.selectedElement) {
                    this.removeSelectionOutline();
                    this.addSelectionOutline(this.selectedElement);
                }
                
                console.log(`Zoom set to ${this.zoom}% - viewBox: ${newX},${newY} ${newWidth}x${newHeight}`);
            }
            
            updateHandleSizes(scale) {
                if (this.selectedElement) {
                    this.removeSelectionOutline();
                    this.addSelectionOutline(this.selectedElement);
                }
            }
            
            // Clear point indicators
            clearPointIndicators() {
                const existingIndicators = this.pointHandles.querySelectorAll('.point-indicator');
                existingIndicators.forEach(indicator => {
                    if (indicator.parentNode) {
                        indicator.parentNode.removeChild(indicator);
                    }
                });
            }
        }

        // Initialize editor
        console.log("Creating SimpleSVGEditor instance...");
        const svgEditor = new SimpleSVGEditor();
        
        // Expose editor to the parent window with enhanced interface
        window.svgEditor = {
            setSvgString: (svgString) => {
                console.log("Setting SVG string:", svgString.substring(0, 50) + "...");
                svgEditor.setSvgString(svgString);
            },
            getSvgString: () => {
                return svgEditor.content.innerHTML;
            },
            clearSelection: () => {
                if (svgEditor.selectedElement) {
                    svgEditor.deselectElement();
                }
                return true;
            }
        };
        
        // Also expose through window.svgedit for iframe compatibility
        window.svgedit = {
            svgEditor: window.svgEditor
        };
        
        console.log("SVG Editor ready");
    </script>
</body>
</html> 